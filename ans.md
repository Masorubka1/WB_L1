Какой самый эффективный способ конкатенации строк?


- В языке Go наиболее эффективным способом конкатенации строк является использование пакета strings и функции Join. Это связано с тем, что в Go строки являются неизменяемыми (immutable) и при каждой операции конкатенации создается новая строка, что может привести к избыточному использованию памяти и производительности.


Что такое интерфейсы, как они применяются в Go?


- В языке Go интерфейсы представляют собой набор методов, которые определяют поведение объекта. Они определяют контракт, который должен быть реализован объектом, чтобы удовлетворять интерфейсу. Интерфейсы в Go предоставляют абстракцию над типами и позволяют реализовывать полиморфизм.

- Интерфейсы в Go применяются для достижения следующих целей:
- Реализация полиморфизма
- Разделение ответственности
- Интеграция с существующим кодом
- Тестирование

- Использование интерфейсов в Go способствует разработке гибкого, расширяемого и легко тестируемого кода. Они позволяют работать с абстракциями и обеспечивают четкое определение требований к объектам, что способствует лучшей структуре программы и повышает ее качество.

Чем отличаются RWMutex от Mutex?

- RWMutex обеспечивает более гибкую синхронизацию доступа к данным, позволяя параллельное чтение и блокируя доступ на запись.


Чем отличаются буферизированные и не буферизированные каналы?


- Не буферизированные каналы (unbuffered channels) обеспечивают синхронизацию отправки и приема данных между горутинами. При отправке значения в не буферизированный канал горутина, отправляющая значение, блокируется до тех пор, пока другая горутина не примет это значение из канала. Аналогично, горутина, принимающая значение из не буферизированного канала, блокируется до тех пор, пока другая горутина не отправит значение в канал. Не буферизированные каналы обеспечивают точку синхронизации между горутинами и гарантируют безопасность доступа к данным.
- Буферизированные каналы (buffered channels) позволяют отправлять и принимать данные без необходимости мгновенной синхронизации. Буферизированный канал имеет фиксированную емкость, которая определяет количество элементов, которые могут быть отправлены в канал до того, как другая горутина примет данные из него. При отправке значения в буферизированный канал, горутина продолжит свое выполнение, если буфер не заполнен, и блокируется только при полном заполнении буфера. Прием данных из буферизированного канала также может быть асинхронным, если буфер содержит данные. Если буфер пуст, то прием данных блокируется до тех пор, пока другая горутина не отправит данные в канал.

Какой размер у структуры struct{}{}?


- В языке Go пустая структура struct{}{} не занимает памяти. Она известна как "пустая структура" или "синглтон-структура". Фактически, пустая структура не содержит полей, поэтому ее размер в памяти равен нулю.
- Пустая структура struct{}{} в основном используется в качестве типа данных для каналов, когда нет необходимости передавать или получать значения, но просто нужно уведомить о событии или выполнить синхронизацию.

Есть ли в Go перегрузка методов или операторов?


- В языке Go нет поддержки перегрузки методов или операторов в том виде, в котором она присутствует, например, в языке C++. В Go перегрузка методов и операторов не разрешена. (каждая функция имеет уникальное название)

В какой последовательности будут выведены элементы map[int]int?

- случайно

В чем разница make и new?


- make -> сложные данные и инициализация полей не 0, возвращает экземпляр
- new -> указатель + 0 значения полей

Сколько существует способов задать переменную типа slice или map?

- []int{1, 2, 3}
- var slice []int
- slice := make([]int, 0, 10)
- slice1 := []int{1, 2, 3}                       // создание slice с помощью литерала
  slice2 := slice1

10 - копия указателя
11 - упадёт из-за неправильной передачи wg
12 - shadowing переменных
13 - изменения в срезе -> изменеия в оригинальном объекте, т.к. срез - ссылка 